{"ast":null,"code":"var _jsxFileName = \"/Users/takuro/Projects/wordle/frontend/src/components/WordleGame/WordleRow.js\";\nimport React from 'react';\nimport styled from 'styled-components';\nimport WordleTile from './WordleTile';\n\n// Стили для строки Wordle\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Row = styled.div`\n  display: flex;\n  gap: 5px;\n  margin-bottom: 5px;\n`;\n\n/**\n * Компонент строки Wordle\n * @param {Object} props - Свойства компонента\n * @param {string} props.word - Слово в строке (текущее или предыдущая попытка)\n * @param {Array} props.result - Результат проверки (массив чисел: 0, 1, 2)\n * @param {number} props.wordLength - Длина загаданного слова\n * @param {boolean} props.isActive - Флаг активности строки (для текущей попытки)\n */\n_c = Row;\nconst WordleRow = ({\n  word = '',\n  result = [],\n  wordLength = 5,\n  isActive = false\n}) => {\n  // Преобразуем слово в массив букв\n  const letters = word.split('');\n\n  // Создаем массив плиток для отображения\n  const tiles = [];\n  for (let i = 0; i < wordLength; i++) {\n    // Определяем состояние плитки\n    let status = 'empty';\n    if (letters[i]) {\n      if (isActive) {\n        // Для текущей попытки все плитки с введенными буквами имеют статус \"filled\"\n        status = 'filled';\n      } else if (result[i] !== undefined) {\n        // Для предыдущих попыток используем результат проверки\n        status = result[i] === 0 ? 'absent' : result[i] === 1 ? 'present' : 'correct';\n      }\n    }\n\n    // Добавляем плитку в массив\n    tiles.push(/*#__PURE__*/_jsxDEV(WordleTile, {\n      letter: letters[i] || '',\n      status: status\n    }, i, false, {\n      fileName: _jsxFileName,\n      lineNumber: 49,\n      columnNumber: 13\n    }, this));\n  }\n  return /*#__PURE__*/_jsxDEV(Row, {\n    children: tiles\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 57,\n    columnNumber: 12\n  }, this);\n};\n_c2 = WordleRow;\nexport default WordleRow;\nvar _c, _c2;\n$RefreshReg$(_c, \"Row\");\n$RefreshReg$(_c2, \"WordleRow\");","map":{"version":3,"names":["React","styled","WordleTile","jsxDEV","_jsxDEV","Row","div","_c","WordleRow","word","result","wordLength","isActive","letters","split","tiles","i","status","undefined","push","letter","fileName","_jsxFileName","lineNumber","columnNumber","children","_c2","$RefreshReg$"],"sources":["/Users/takuro/Projects/wordle/frontend/src/components/WordleGame/WordleRow.js"],"sourcesContent":["import React from 'react';\nimport styled from 'styled-components';\nimport WordleTile from './WordleTile';\n\n// Стили для строки Wordle\nconst Row = styled.div`\n  display: flex;\n  gap: 5px;\n  margin-bottom: 5px;\n`;\n\n/**\n * Компонент строки Wordle\n * @param {Object} props - Свойства компонента\n * @param {string} props.word - Слово в строке (текущее или предыдущая попытка)\n * @param {Array} props.result - Результат проверки (массив чисел: 0, 1, 2)\n * @param {number} props.wordLength - Длина загаданного слова\n * @param {boolean} props.isActive - Флаг активности строки (для текущей попытки)\n */\nconst WordleRow = ({\n    word = '',\n    result = [],\n    wordLength = 5,\n    isActive = false\n}) => {\n    // Преобразуем слово в массив букв\n    const letters = word.split('');\n\n    // Создаем массив плиток для отображения\n    const tiles = [];\n\n    for (let i = 0; i < wordLength; i++) {\n        // Определяем состояние плитки\n        let status = 'empty';\n        if (letters[i]) {\n            if (isActive) {\n                // Для текущей попытки все плитки с введенными буквами имеют статус \"filled\"\n                status = 'filled';\n            } else if (result[i] !== undefined) {\n                // Для предыдущих попыток используем результат проверки\n                status = result[i] === 0 ? 'absent' :\n                    result[i] === 1 ? 'present' :\n                        'correct';\n            }\n        }\n\n        // Добавляем плитку в массив\n        tiles.push(\n            <WordleTile\n                key={i}\n                letter={letters[i] || ''}\n                status={status}\n            />\n        );\n    }\n\n    return <Row>{tiles}</Row>;\n};\n\nexport default WordleRow; "],"mappings":";AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAOC,MAAM,MAAM,mBAAmB;AACtC,OAAOC,UAAU,MAAM,cAAc;;AAErC;AAAA,SAAAC,MAAA,IAAAC,OAAA;AACA,MAAMC,GAAG,GAAGJ,MAAM,CAACK,GAAG;AACtB;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPAC,EAAA,GANMF,GAAG;AAcT,MAAMG,SAAS,GAAGA,CAAC;EACfC,IAAI,GAAG,EAAE;EACTC,MAAM,GAAG,EAAE;EACXC,UAAU,GAAG,CAAC;EACdC,QAAQ,GAAG;AACf,CAAC,KAAK;EACF;EACA,MAAMC,OAAO,GAAGJ,IAAI,CAACK,KAAK,CAAC,EAAE,CAAC;;EAE9B;EACA,MAAMC,KAAK,GAAG,EAAE;EAEhB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,UAAU,EAAEK,CAAC,EAAE,EAAE;IACjC;IACA,IAAIC,MAAM,GAAG,OAAO;IACpB,IAAIJ,OAAO,CAACG,CAAC,CAAC,EAAE;MACZ,IAAIJ,QAAQ,EAAE;QACV;QACAK,MAAM,GAAG,QAAQ;MACrB,CAAC,MAAM,IAAIP,MAAM,CAACM,CAAC,CAAC,KAAKE,SAAS,EAAE;QAChC;QACAD,MAAM,GAAGP,MAAM,CAACM,CAAC,CAAC,KAAK,CAAC,GAAG,QAAQ,GAC/BN,MAAM,CAACM,CAAC,CAAC,KAAK,CAAC,GAAG,SAAS,GACvB,SAAS;MACrB;IACJ;;IAEA;IACAD,KAAK,CAACI,IAAI,cACNf,OAAA,CAACF,UAAU;MAEPkB,MAAM,EAAEP,OAAO,CAACG,CAAC,CAAC,IAAI,EAAG;MACzBC,MAAM,EAAEA;IAAO,GAFVD,CAAC;MAAAK,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAGT,CACL,CAAC;EACL;EAEA,oBAAOpB,OAAA,CAACC,GAAG;IAAAoB,QAAA,EAAEV;EAAK;IAAAM,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAAM,CAAC;AAC7B,CAAC;AAACE,GAAA,GAtCIlB,SAAS;AAwCf,eAAeA,SAAS;AAAC,IAAAD,EAAA,EAAAmB,GAAA;AAAAC,YAAA,CAAApB,EAAA;AAAAoB,YAAA,CAAAD,GAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}